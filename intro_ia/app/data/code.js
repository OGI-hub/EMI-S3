// ==========================================
// Code Python Essentiel - Exercices à trous
// Complétez les parties manquantes
// ==========================================

const codeData = {
    bfs: {
        title: "BFS - Breadth-First Search",
        description: "Complétez l'implémentation de BFS. Rappel: BFS utilise une FILE (FIFO).",
        code: [
            { line: 1, content: "from collections import deque", type: "normal" },
            { line: 2, content: "", type: "empty" },
            { line: 3, content: "def bfs(graph, start, goal):", type: "function" },
            { line: 4, content: "    # Initialiser la file avec le nœud de départ", type: "comment" },
            { line: 5, content: "    frontier = ___BLANK1___", type: "blank", blankId: "BLANK1", answer: "deque([start])" },
            { line: 6, content: "    visited = ___BLANK2___", type: "blank", blankId: "BLANK2", answer: "set()" },
            { line: 7, content: "", type: "empty" },
            { line: 8, content: "    while frontier:", type: "normal" },
            { line: 9, content: "        # Retirer le premier élément (FIFO)", type: "comment" },
            { line: 10, content: "        current = frontier.___BLANK3___()", type: "blank", blankId: "BLANK3", answer: "popleft" },
            { line: 11, content: "", type: "empty" },
            { line: 12, content: "        if current == goal:", type: "normal" },
            { line: 13, content: "            return True  # But trouvé!", type: "normal" },
            { line: 14, content: "", type: "empty" },
            { line: 15, content: "        if current not in visited:", type: "normal" },
            { line: 16, content: "            visited.___BLANK4___(current)", type: "blank", blankId: "BLANK4", answer: "add" },
            { line: 17, content: "", type: "empty" },
            { line: 18, content: "            for neighbor in graph[current]:", type: "normal" },
            { line: 19, content: "                if neighbor not in visited:", type: "normal" },
            { line: 20, content: "                    frontier.___BLANK5___(neighbor)", type: "blank", blankId: "BLANK5", answer: "append" },
            { line: 21, content: "", type: "empty" },
            { line: 22, content: "    return False  # But non trouvé", type: "normal" }
        ],
        blanks: [
            { id: "BLANK1", options: ["deque([start])", "[]", "[start]", "set()"], correct: "deque([start])" },
            { id: "BLANK2", options: ["set()", "[]", "{start}", "deque()"], correct: "set()" },
            { id: "BLANK3", options: ["popleft", "pop", "remove", "get"], correct: "popleft" },
            { id: "BLANK4", options: ["add", "append", "insert", "push"], correct: "add" },
            { id: "BLANK5", options: ["append", "appendleft", "add", "push"], correct: "append" }
        ],
        explanation: "BFS utilise `deque` pour la file. `popleft()` retire le premier élément (FIFO). `append()` ajoute à la fin. L'ensemble `visited` avec `add()` évite les doublons."
    },
    dfs: {
        title: "DFS - Depth-First Search",
        description: "Complétez l'implémentation de DFS. Rappel: DFS utilise une PILE (LIFO).",
        code: [
            { line: 1, content: "def dfs(graph, start, goal):", type: "function" },
            { line: 2, content: "    # Initialiser la pile avec le nœud de départ", type: "comment" },
            { line: 3, content: "    stack = ___BLANK1___", type: "blank", blankId: "BLANK1", answer: "[start]" },
            { line: 4, content: "    visited = set()", type: "normal" },
            { line: 5, content: "", type: "empty" },
            { line: 6, content: "    while stack:", type: "normal" },
            { line: 7, content: "        # Retirer le dernier élément (LIFO)", type: "comment" },
            { line: 8, content: "        current = stack.___BLANK2___()", type: "blank", blankId: "BLANK2", answer: "pop" },
            { line: 9, content: "", type: "empty" },
            { line: 10, content: "        if current == goal:", type: "normal" },
            { line: 11, content: "            return True", type: "normal" },
            { line: 12, content: "", type: "empty" },
            { line: 13, content: "        if current ___BLANK3___ visited:", type: "blank", blankId: "BLANK3", answer: "not in" },
            { line: 14, content: "            visited.add(current)", type: "normal" },
            { line: 15, content: "", type: "empty" },
            { line: 16, content: "            for neighbor in graph[current]:", type: "normal" },
            { line: 17, content: "                stack.___BLANK4___(neighbor)", type: "blank", blankId: "BLANK4", answer: "append" },
            { line: 18, content: "", type: "empty" },
            { line: 19, content: "    return ___BLANK5___", type: "blank", blankId: "BLANK5", answer: "False" }
        ],
        blanks: [
            { id: "BLANK1", options: ["[start]", "deque([start])", "set()", "(start)"], correct: "[start]" },
            { id: "BLANK2", options: ["pop", "popleft", "remove", "get"], correct: "pop" },
            { id: "BLANK3", options: ["not in", "in", "==", "!="], correct: "not in" },
            { id: "BLANK4", options: ["append", "insert", "add", "extend"], correct: "append" },
            { id: "BLANK5", options: ["False", "True", "None", "-1"], correct: "False" }
        ],
        explanation: "DFS utilise une liste comme pile. `pop()` retire le dernier élément (LIFO). Contrairement à BFS, on n'a pas besoin de `deque`."
    },
    astar: {
        title: "A* - Algorithme A-Star",
        description: "Complétez A* avec f(n) = g(n) + h(n). Utilise `heapq` pour la file de priorité.",
        code: [
            { line: 1, content: "import heapq", type: "normal" },
            { line: 2, content: "", type: "empty" },
            { line: 3, content: "def astar(graph, start, goal, h):", type: "function" },
            { line: 4, content: "    # h est un dictionnaire des heuristiques h[node]", type: "comment" },
            { line: 5, content: "    # (f, g, node)", type: "comment" },
            { line: 6, content: "    frontier = [(___BLANK1___, 0, start)]", type: "blank", blankId: "BLANK1", answer: "h[start]" },
            { line: 7, content: "    visited = set()", type: "normal" },
            { line: 8, content: "    g_cost = {start: 0}", type: "normal" },
            { line: 9, content: "", type: "empty" },
            { line: 10, content: "    while frontier:", type: "normal" },
            { line: 11, content: "        f, g, current = heapq.___BLANK2___(frontier)", type: "blank", blankId: "BLANK2", answer: "heappop" },
            { line: 12, content: "", type: "empty" },
            { line: 13, content: "        if current == goal:", type: "normal" },
            { line: 14, content: "            return g  # Coût du chemin", type: "normal" },
            { line: 15, content: "", type: "empty" },
            { line: 16, content: "        if current in visited:", type: "normal" },
            { line: 17, content: "            continue", type: "normal" },
            { line: 18, content: "        visited.add(current)", type: "normal" },
            { line: 19, content: "", type: "empty" },
            { line: 20, content: "        for neighbor, cost in graph[current]:", type: "normal" },
            { line: 21, content: "            new_g = g + ___BLANK3___", type: "blank", blankId: "BLANK3", answer: "cost" },
            { line: 22, content: "            new_f = new_g + ___BLANK4___", type: "blank", blankId: "BLANK4", answer: "h[neighbor]" },
            { line: 23, content: "            heapq.___BLANK5___(frontier, (new_f, new_g, neighbor))", type: "blank", blankId: "BLANK5", answer: "heappush" },
            { line: 24, content: "", type: "empty" },
            { line: 25, content: "    return -1  # Pas de chemin", type: "normal" }
        ],
        blanks: [
            { id: "BLANK1", options: ["h[start]", "0", "g[start]", "1"], correct: "h[start]" },
            { id: "BLANK2", options: ["heappop", "heappush", "pop", "get"], correct: "heappop" },
            { id: "BLANK3", options: ["cost", "1", "h[neighbor]", "g"], correct: "cost" },
            { id: "BLANK4", options: ["h[neighbor]", "cost", "g", "0"], correct: "h[neighbor]" },
            { id: "BLANK5", options: ["heappush", "heappop", "append", "add"], correct: "heappush" }
        ],
        explanation: "A* utilise `heapq` pour toujours explorer le nœud avec le plus petit f(n). f = g + h, où g est le coût réel et h l'estimation."
    },
    puzzle: {
        title: "8-Puzzle - Classe d'État",
        description: "Complétez la classe PuzzleState pour représenter un état du 8-puzzle.",
        code: [
            { line: 1, content: "class PuzzleState:", type: "function" },
            { line: 2, content: "    def __init__(self, board, parent=None, move=None, depth=0):", type: "normal" },
            { line: 3, content: "        self.board = ___BLANK1___  # tuple pour hashabilité", type: "blank", blankId: "BLANK1", answer: "tuple(board)" },
            { line: 4, content: "        self.parent = parent", type: "normal" },
            { line: 5, content: "        self.move = move", type: "normal" },
            { line: 6, content: "        self.depth = depth", type: "normal" },
            { line: 7, content: "", type: "empty" },
            { line: 8, content: "    def find_blank(self):", type: "normal" },
            { line: 9, content: "        idx = self.board.___BLANK2___(0)", type: "blank", blankId: "BLANK2", answer: "index" },
            { line: 10, content: "        return idx // 3, idx % 3  # (row, col)", type: "normal" },
            { line: 11, content: "", type: "empty" },
            { line: 12, content: "    def successors(self):", type: "normal" },
            { line: 13, content: "        r, c = self.find_blank()", type: "normal" },
            { line: 14, content: "        moves = [(-1,0,'UP'), (1,0,'DOWN'),", type: "normal" },
            { line: 15, content: "                 (0,-1,'LEFT'), (0,1,'RIGHT')]", type: "normal" },
            { line: 16, content: "        result = []", type: "normal" },
            { line: 17, content: "        for dr, dc, name in moves:", type: "normal" },
            { line: 18, content: "            nr, nc = r + ___BLANK3___, c + ___BLANK4___", type: "blank", blankId: "BLANK3", answer: "dr" },
            { line: 19, content: "            if 0 <= nr < 3 and 0 <= nc < 3:", type: "normal" },
            { line: 20, content: "                new_board = list(self.board)", type: "normal" },
            { line: 21, content: "                # Échanger les positions", type: "comment" },
            { line: 22, content: "                old_idx = r*3 + c", type: "normal" },
            { line: 23, content: "                new_idx = nr*3 + nc", type: "normal" },
            { line: 24, content: "                new_board[old_idx], new_board[new_idx] = \\", type: "normal" },
            { line: 25, content: "                    new_board[___BLANK5___], new_board[old_idx]", type: "blank", blankId: "BLANK5", answer: "new_idx" },
            { line: 26, content: "                result.append(PuzzleState(new_board, self, name, self.depth+1))", type: "normal" },
            { line: 27, content: "        return result", type: "normal" }
        ],
        blanks: [
            { id: "BLANK1", options: ["tuple(board)", "list(board)", "board", "set(board)"], correct: "tuple(board)" },
            { id: "BLANK2", options: ["index", "find", "search", "locate"], correct: "index" },
            { id: "BLANK3", options: ["dr", "dc", "1", "0"], correct: "dr" },
            { id: "BLANK4", options: ["dc", "dr", "1", "0"], correct: "dc" },
            { id: "BLANK5", options: ["new_idx", "old_idx", "0", "1"], correct: "new_idx" }
        ],
        explanation: "Le board est converti en tuple pour pouvoir être hashé (utilisé dans un set). `index(0)` trouve la case vide. L'échange se fait entre la case vide et la case cible."
    },
    heuristics: {
        title: "Calcul des Heuristiques",
        description: "Complétez les fonctions de calcul d'heuristiques pour le 8-puzzle.",
        code: [
            { line: 1, content: "def misplaced_tiles(state, goal):", type: "function" },
            { line: 2, content: "    '''Compte les tuiles mal placées'''", type: "comment" },
            { line: 3, content: "    count = 0", type: "normal" },
            { line: 4, content: "    for i in range(9):", type: "normal" },
            { line: 5, content: "        if state[i] != 0 and state[i] != ___BLANK1___:", type: "blank", blankId: "BLANK1", answer: "goal[i]" },
            { line: 6, content: "            count += 1", type: "normal" },
            { line: 7, content: "    return count", type: "normal" },
            { line: 8, content: "", type: "empty" },
            { line: 9, content: "def manhattan_distance(state, goal):", type: "function" },
            { line: 10, content: "    '''Calcule la somme des distances Manhattan'''", type: "comment" },
            { line: 11, content: "    distance = 0", type: "normal" },
            { line: 12, content: "    for i in range(9):", type: "normal" },
            { line: 13, content: "        if state[i] != 0:", type: "normal" },
            { line: 14, content: "            # Position actuelle", type: "comment" },
            { line: 15, content: "            curr_row, curr_col = i // 3, i ___BLANK2___ 3", type: "blank", blankId: "BLANK2", answer: "%" },
            { line: 16, content: "            # Position but", type: "comment" },
            { line: 17, content: "            goal_idx = goal.index(state[i])", type: "normal" },
            { line: 18, content: "            goal_row, goal_col = goal_idx // 3, goal_idx % 3", type: "normal" },
            { line: 19, content: "            # Manhattan = |dx| + |dy|", type: "comment" },
            { line: 20, content: "            distance += ___BLANK3___(curr_row - goal_row) + \\", type: "blank", blankId: "BLANK3", answer: "abs" },
            { line: 21, content: "                        abs(curr_col - goal_col)", type: "normal" },
            { line: 22, content: "    return distance", type: "normal" },
            { line: 23, content: "", type: "empty" },
            { line: 24, content: "def euclidean_distance(state, goal):", type: "function" },
            { line: 25, content: "    '''Calcule la somme des distances Euclidiennes'''", type: "comment" },
            { line: 26, content: "    import math", type: "normal" },
            { line: 27, content: "    distance = 0", type: "normal" },
            { line: 28, content: "    for i in range(9):", type: "normal" },
            { line: 29, content: "        if state[i] != 0:", type: "normal" },
            { line: 30, content: "            curr_row, curr_col = i // 3, i % 3", type: "normal" },
            { line: 31, content: "            goal_idx = goal.index(state[i])", type: "normal" },
            { line: 32, content: "            goal_row, goal_col = goal_idx // 3, goal_idx % 3", type: "normal" },
            { line: 33, content: "            dx = curr_row - goal_row", type: "normal" },
            { line: 34, content: "            dy = curr_col - goal_col", type: "normal" },
            { line: 35, content: "            distance += math.___BLANK4___(dx**2 + dy**2)", type: "blank", blankId: "BLANK4", answer: "sqrt" },
            { line: 36, content: "    return distance", type: "normal" }
        ],
        blanks: [
            { id: "BLANK1", options: ["goal[i]", "state[i]", "i", "0"], correct: "goal[i]" },
            { id: "BLANK2", options: ["%", "//", "/", "*"], correct: "%" },
            { id: "BLANK3", options: ["abs", "int", "sum", "max"], correct: "abs" },
            { id: "BLANK4", options: ["sqrt", "pow", "abs", "floor"], correct: "sqrt" }
        ],
        explanation: "Pour les tuiles mal placées, on compare chaque position. Manhattan utilise |Δx| + |Δy|. Euclidienne utilise √(Δx² + Δy²). Le modulo % donne la colonne."
    }
};
