Q: Dans un projet Maven, quel fichier définit les dépendances, plugins et configuration du build ? || R: pom.xml (Project Object Model) || Pièges: [build.gradle (Configuration Gradle)]: build.gradle est utilisé par Gradle, pas Maven - confusion fréquente entre les deux outils de build Java. // [package.json (Configuration Node)]: package.json est le fichier de configuration pour npm/Node.js, pas pour les projets Java. // [settings.xml (Global Config)]: settings.xml configure Maven globalement (credentials, proxies) mais ne définit pas les dépendances du projet.
Q: Quelle commande Maven permet de compiler le code source SANS exécuter les tests ? || R: mvn clean package -DskipTests || Pièges: [mvn compile -DskipTests=true]: mvn compile ne fait que compiler, sans packager. De plus, elle n'inclut pas l'option pour skip les tests. // [mvn build --no-tests --force]: La syntaxe --no-tests n'existe pas dans Maven. C'est une confusion avec d'autres outils. // [mvn package --skip-tests all]: La syntaxe --skip-tests est incorrecte. Maven utilise -DskipTests (avec D majuscule).
Q: Pour un projet .NET, quelle commande restaure les dépendances NuGet avant la compilation ? || R: dotnet restore || Pièges: [dotnet install]: dotnet install n'existe pas. C'est une confusion avec npm install. // [nuget restore]: nuget restore existe mais n'est pas la commande dotnet CLI standard utilisée dans les pipelines modernes. // [dotnet packages]: dotnet packages n'est pas une commande valide.
Q: Quel plugin Jenkins est nécessaire pour exécuter des builds Maven dans les pipelines ? || R: Maven Integration || Pièges: [Maven Builder]: Maven Builder n'est pas le nom officiel du plugin. // [Apache Maven]: Apache Maven n'est pas un nom de plugin Jenkins. // [Build Maven]: Build Maven n'existe pas comme plugin Jenkins.
Q: Dans Node.js, quelle est la différence entre 'npm install' et 'npm ci' ? || R: npm ci utilise package-lock.json pour une installation déterministe (CI/CD) || Pièges: [npm ci installe uniquement les dépendances de développement (devDependencies)]: npm ci installe TOUTES les dépendances, pas seulement celles de développement. // [npm install est recommandé pour les pipelines CI/CD car il est plus rapide]: C'est l'inverse : npm ci est souvent plus rapide car il supprime node_modules et fait une installation propre. // [npm ci génère automatiquement un nouveau fichier package-lock.json]: npm ci requiert que package.json et package-lock.json existent déjà.
Q: Dans un fichier .gitlab-ci.yml, quel mot-clé définit les étapes du pipeline dans l'ordre ? || R: stages || Pièges: [phases]: phases est utilisé dans Maven, pas dans GitLab CI/CD. // [steps]: steps est utilisé dans Jenkins ou GitHub Actions, pas GitLab. // [jobs]: jobs définit les tâches individuelles, pas les étapes globales du pipeline.
Q: Quelle clé GitLab CI/CD permet de spécifier l'image Docker à utiliser pour un job ? || R: image: || Pièges: [container:]: container: n'est pas une clé GitLab CI/CD valide. // [docker:]: docker: n'est pas utilisé pour spécifier l'image du job. // [from:]: from: est utilisé dans Dockerfile, pas dans .gitlab-ci.yml.
Q: Dans GitLab CI/CD, que permet la clé 'artifacts' ? || R: Conserver et partager des fichiers générés entre jobs/stages || Pièges: [Télécharger automatiquement les dépendances externes du projet]: Les dépendances sont gérées par les gestionnaires de packages (Maven, npm), pas par artifacts. // [Définir les variables d'environnement globales pour le pipeline]: Les variables d'environnement sont définies avec 'variables:'. // [Configurer le cache Docker pour accélérer les builds futurs]: Le cache Docker est géré différemment, avec 'cache:' pour les fichiers.
Q: Quelle image Docker est recommandée pour builder un projet Spring Boot dans GitLab CI ? || R: maven:3.9-eclipse-temurin-17 || Pièges: [openjdk:17-jdk-alpine]: openjdk:17 contient le JDK mais pas Maven, donc mvn ne fonctionnera pas. // [springboot:latest-stable]: springboot:latest n'est pas une image Docker officielle. // [java:17-maven-builder]: java:17-maven n'est pas le format standard des images Docker officielles.
Q: Que fait la clé 'needs' dans un job GitLab CI/CD ? || R: Permet d'exécuter un job sans attendre la fin du stage précédent (DAG) || Pièges: [Définit les pré-requis système obligatoires pour le job]: Les dépendances système sont gérées dans le script ou via l'image Docker. // [Spécifie les tags du runner requis pour l'exécution]: Les tags du runner sont définis avec 'tags:', pas 'needs:'. // [Configure les secrets et variables nécessaires au job]: Les secrets sont gérés via les variables CI/CD de GitLab.
Q: Quelle commande vérifie que Docker est correctement installé et fonctionnel ? || R: docker run hello-world || Pièges: [docker status]: docker status n'est pas une commande Docker valide. // [docker check]: docker check n'existe pas. // [docker test]: docker test n'est pas une commande Docker.
Q: Pour déployer une application Spring Boot sur Tomcat externe, quel type de packaging faut-il utiliser ? || R: <packaging>war</packaging> || Pièges: [<packaging>jar</packaging>]: JAR est le format par défaut pour Spring Boot standalone, mais ne se déploie pas sur Tomcat externe. // [<packaging>ear</packaging>]: EAR (Enterprise Archive) est pour les applications Java EE complètes, pas Spring Boot. // [<packaging>zip</packaging>]: ZIP n'est pas un format de packaging Maven standard.
Q: Pourquoi faut-il déclarer spring-boot-starter-tomcat avec scope 'provided' pour un déploiement sur Tomcat externe ? || R: Pour activer le mode debug du plugin Tomcat Maven au déploiement || Pièges: [Pour éviter les conflits de version avec le serveur Tomcat embarqué dans le JAR]: Partiellement vrai mais incomplet. // [Parce que le serveur Tomcat externe fournit déjà ces bibliothèques à l'exécution]: Partiellement vrai mais incomplet. // [Pour réduire la taille du fichier WAR final en excluant ces librairies]: Partiellement vrai mais incomplet.
Q: Quelle classe doit être créée pour permettre à Spring Boot de s'initialiser dans un conteneur Servlet externe ? || R: ServletInitializer extends SpringBootServletInitializer || Pièges: [TomcatInitializer]: TomcatInitializer n'est pas une classe standard Spring Boot. // [WebApplicationInitializer]: WebApplicationInitializer est une interface Spring, mais pas la bonne approche pour Spring Boot. // [BootstrapServlet]: BootstrapServlet n'existe pas dans ce contexte.
Q: Dans quel dossier Tomcat faut-il copier le fichier .war pour le déployer ? || R: /var/lib/tomcat/webapps/ || Pièges: [/var/lib/tomcat/deploy/]: Le dossier deploy/ n'est pas le standard Tomcat. // [/var/lib/tomcat/applications/]: applications/ n'est pas un dossier Tomcat standard. // [/var/lib/tomcat/wars/]: wars/ n'existe pas dans la structure Tomcat.
Q: Quelle clé GitLab CI/CD permet de s'assurer qu'un job de déploiement récupère les artifacts d'un job de build précédent ? || R: needs: [{job: 'build', artifacts: true}] || Pièges: [dependencies: [job: build, artifacts: true]]: dependencies: existe mais 'needs' avec artifacts est plus explicite pour le DAG. // [artifacts: {download: true, from: 'build'}]: Cette syntaxe n'existe pas dans GitLab CI/CD. // [get_artifacts: {job: 'build', required: true}]: get_artifacts n'est pas une clé valide.
Q: Quelle variable d'environnement GitLab CI/CD stocke le token d'authentification SonarCloud ? || R: SONAR_TOKEN || Pièges: [SONAR_PASSWORD]: SonarCloud utilise des tokens, pas des mots de passe traditionnels. // [SONAR_API_KEY]: SONAR_API_KEY n'est pas le nom de variable standard. // [SONARCLOUD_SECRET]: SONARCLOUD_SECRET n'est pas une convention utilisée.
Q: Quel goal Maven exécute l'analyse SonarCloud ? || R: mvn sonar:sonar || Pièges: [mvn sonar:analyze]: sonar:analyze n'est pas le goal correct. // [mvn sonar:scan]: sonar:scan n'existe pas dans le plugin Maven SonarQube. // [mvn sonarcloud:check]: sonarcloud:check n'est pas un goal Maven valide.
Q: Quelle propriété Maven spécifie l'URL du serveur SonarCloud ? || R: -Dsonar.host.url || Pièges: [-Dsonar.server.url]: sonar.server.url n'est pas la propriété correcte. // [-Dsonar.cloud.url]: sonar.cloud.url n'existe pas. // [-Dsonar.endpoint]: sonar.endpoint n'est pas une propriété SonarQube valide.
Q: Qu'est-ce qu'un 'Code Smell' détecté par SonarCloud ? || R: Un problème de maintenabilité qui n'est pas un bug || Pièges: [Une faille de sécurité critique]: Les failles de sécurité sont classées comme 'Vulnerabilities', pas Code Smells. // [Un test unitaire qui échoue]: Les tests qui échouent sont des erreurs de build, pas des Code Smells. // [Une dépendance obsolète]: Les dépendances obsolètes peuvent être détectées mais ne sont pas des Code Smells.
Q: Dans Jenkins, comment configure-t-on le serveur SonarCloud ? || R: Manage Jenkins → Configure System → SonarQube servers || Pièges: [Manage Jenkins → Global Tool Configuration]: Global Tool Configuration est pour les outils comme Maven ou JDK, pas les serveurs SonarCloud. // [Manage Jenkins → Plugins → SonarCloud Settings]: La section Plugins ne contient pas de settings SonarCloud. // [Job Configuration → SonarCloud Section]: La configuration serveur est globale, pas au niveau du job.
Q: Que signifie SAST dans le contexte DevSecOps ? || R: Static Application Security Testing || Pièges: [Security Analysis and Software Testing]: Ce n'est pas le bon acronyme. // [Secure Application Scanning Tool]: SAST n'est pas un outil spécifique mais une catégorie de testing. // [Source Application Security Test]: Ce n'est pas la définition correcte.
Q: Quelle vulnérabilité SAST est identifiée par CWE-89 ? || R: SQL Injection via paramètres non échappés || Pièges: [Cross-Site Scripting (XSS) via DOM]: XSS est CWE-79, pas CWE-89. // [Buffer Overflow de la pile d'exécution]: Buffer Overflow a un CWE différent. // [Broken Authentication et Session hijacking]: Broken Authentication n'est pas CWE-89.
Q: Quel outil GitLab détecte les secrets (clés API, tokens) codés en dur dans le code ? || R: Gitleaks (Détection de secrets hardcodés) || Pièges: [Semgrep (Analyse SAST généraliste)]: Semgrep est utilisé pour SAST, pas Secret Detection. // [OWASP Dependency Check (Scan dépendances)]: OWASP Dependency Check analyse les dépendances vulnérables, pas les secrets. // [Trivy (Scan de conteneurs et fs)]: Trivy analyse les vulnérabilités des conteneurs Docker, pas les secrets dans le code.
Q: Selon les bonnes pratiques DevSecOps, comment doit-on corriger chaque vulnérabilité détectée ? || R: Une vulnérabilité = une branche = une Merge Request || Pièges: [Regrouper toutes les corrections dans une seule 'release branch']: Regrouper les corrections rend le suivi et la revue difficiles. // [Commit direct sur main pour corriger au plus vite (Hotfix)]: Les commits directs sur main violent les bonnes pratiques de protection des branches. // [Ignorer les vulnérabilités non-critiques temporairement]: Aucune vulnérabilité ne doit être ignorée sans analyse.
Q: Comment corriger un secret détecté dans un fichier .env versionné ? || R: Ajouter .env au .gitignore et utiliser des variables CI/CD || Pièges: [Supprimer le secret du fichier et laisser l'historique tel quel]: Supprimer sans ajouter au .gitignore n'empêche pas le ré-ajout accidentel. // [Renommer le fichier en .env.safe et le chiffrer manuellement]: Renommer ne résout pas le problème de sécurité. // [Encoder le secret en base64 dans le fichier pour le masquer]: Base64 n'est pas un chiffrement, le secret reste visible.
Q: Quelle est la différence principale entre Merge et Rebase ? || R: Rebase crée un historique linéaire, Merge garde l'historique de fusion || Pièges: [Merge est plus rapide mais perd l'historique, Rebase est plus lent]: La vitesse n'est pas la différence principale. // [Merge est interdit sur main, Rebase est la seule option valide]: Merge est autorisé sur les branches protégées via MR. // [Rebase ne fonctionne que localement, Merge fonctionne sur le serveur]: Rebase fonctionne parfaitement avec GitLab.
Q: Quel fichier Ansible définit les machines cibles (hosts) à configurer ? || R: inventory || Pièges: [hosts.yml]: hosts.yml peut être un format mais 'inventory' est le terme générique. // [targets.conf]: targets.conf n'est pas un fichier Ansible standard. // [machines.ini]: machines.ini n'est pas utilisé par Ansible.
Q: Quelle commande Ansible teste la connectivité SSH vers tous les hosts de l'inventory ? || R: ansible all -m ping || Pièges: [ansible all -m ssh-test]: ssh-test n'est pas un module Ansible. // [ansible-ping --all]: La syntaxe ansible-ping n'existe pas. // [ansible-check connectivity]: ansible-check n'est pas une commande valide.
Q: Comment s'appelle un fichier Ansible YAML définissant une série de tâches à exécuter ? || R: Playbook || Pièges: [Runbook]: Runbook est un terme général d'opérations, pas spécifique à Ansible. // [Taskfile]: Taskfile est utilisé par d'autres outils, pas Ansible. // [Recipe]: Recipe est terminologie Chef, pas Ansible.
Q: Quel module Ansible permet de copier un fichier vers un host distant ? || R: copy || Pièges: [file]: Le module 'file' gère les permissions et la création de fichiers/dossiers, pas la copie. // [transfer]: transfer n'est pas un module Ansible. // [scp]: scp n'est pas un module Ansible, c'est une commande système.
Q: Dans un Jenkinsfile, comment exécuter un playbook Ansible sur une machine distante via SSH ? || R: sh 'ssh user@host ansible-playbook playbook.yml' || Pièges: [ansiblePlaybook playbook: 'deploy.yml']: ansiblePlaybook est un DSL Jenkins Ansible plugin mais la question parle d'exécution SSH distante. // [ansible { playbook 'deploy.yml' }]: Cette syntaxe n'est pas valide dans un Jenkinsfile. // [runAnsible 'deploy.yml']: runAnsible n'est pas une commande Jenkins standard.
Q: Quelle est la différence entre Jenkins et GitLab CI/CD dans la définition des pipelines ? || R: Jenkins utilise Jenkinsfile (Groovy), GitLab utilise .gitlab-ci.yml (YAML) || Pièges: [Jenkins utilise YAML déclaratif, GitLab utilise Groovy scripté]: C'est l'inverse : Jenkins utilise Groovy, GitLab utilise YAML. // [Les deux utilisent exactement le même format standard (CNCF)]: Les formats sont différents (Groovy vs YAML). // [GitLab n'a pas de pipeline code, tout se fait via l'interface UI]: GitLab a bien des pipelines composés de stages et jobs.
Q: Quel fichier est équivalent au pom.xml pour un projet Node.js ? || R: package.json || Pièges: [node.xml]: node.xml n'existe pas. // [npm.config]: npm.config n'est pas le fichier principal de configuration projet. // [dependencies.json]: dependencies.json n'est pas un fichier Node.js standard.
Q: Quel est l'équivalent de 'mvn clean package' pour un projet .NET ? || R: dotnet restore && dotnet build --configuration Release || Pièges: [dotnet clean build]: La syntaxe 'dotnet clean build' n'est pas valide en une seule commande. // [dotnet package]: 'dotnet package' n'existe pas comme commande directe. // [dotnet compile release]: 'dotnet compile' n'est pas une commande valide.
Q: Lors d'un déploiement GitLab CI/CD sur un serveur local (Tomcat), quel type de runner est nécessaire ? || R: Shell runner configuré avec le tag approprié || Pièges: [Docker runner avec accès privilégié (dind)]: Docker runner isole le job et n'a pas accès direct aux services locaux. // [Kubernetes runner sur le même cluster]: Kubernetes runner est pour les déploiements cloud, pas locaux. // [SSH runner connecté au localhost]: SSH runner exécuterait sur une machine distante, pas locale.
Q: Quelle clé GitLab CI/CD restreint l'exécution d'un job à la branche main uniquement ? || R: only: [main] || Pièges: [branch: main]: 'branch:' n'est pas une clé GitLab CI/CD valide. // [restrict: main]: 'restrict:' n'existe pas dans la syntaxe GitLab. // [when: main]: 'when:' définit des conditions différentes (on_success, manual, etc.).
Q: Dans le contexte CI/CD, que signifie 'artifact' ? || R: Un fichier généré par le build (JAR/WAR) à conserver || Pièges: [Un fichier de configuration pour le runner]: Les fichiers YAML sont des configurations, pas des artifacts de build. // [Un log détaillé de l'exécution du job]: Les logs ne sont pas des artifacts au sens CI/CD. // [Un secret chiffré stocké temporairement]: Les secrets sont stockés dans les variables CI/CD, pas comme artifacts.
Q: Quel est le rôle de la variable GIT_DEPTH dans GitLab CI/CD ? || R: Limiter le nombre de commits clonés (shallow clone) || Pièges: [Définir la profondeur maximale des sous-modules]: Les sous-modules ont leur propre configuration. // [Configurer le niveau de logs Git]: GIT_DEPTH ne concerne pas les logs. // [Définir le nombre de branches à cloner]: GIT_DEPTH ne limite pas les branches mais les commits.
Q: Pour protéger une branche dans GitLab, quel paramètre empêche les push directs ? || R: Allowed to push: No one || Pièges: [Push protection: enabled]: Cette option n'existe pas avec cette syntaxe dans GitLab. // [Direct push: false]: Cette configuration n'existe pas. // [Merge only: true]: 'Merge only' n'est pas un paramètre GitLab direct.
Q: Quelle commande permet de vérifier la version de Maven installée sur votre machine ? || R: mvn -v || Pièges: [maven --version]: L'exécutable s'appelle 'mvn', pas 'maven'. // [mvn --check]: --check n'est pas une option Maven valide. // [maven -version]: L'exécutable n'est pas 'maven' mais 'mvn'.
Q: Pour créer un nouveau projet console .NET, quelle commande utilise-t-on ? || R: dotnet new console -n MonProjet || Pièges: [dotnet create application console]: 'create' n'est pas la commande correcte, c'est 'new'. // [dotnet init --type console]: 'init' n'existe pas dans dotnet CLI. // [dotnet generate console-app]: 'generate' n'est pas une commande dotnet.
Q: Où stocke-t-on la clé initiale pour déverrouiller Jenkins après installation sur Linux ? || R: /var/lib/jenkins/secrets/initialAdminPassword || Pièges: [/etc/jenkins/config/adminPassword]: Ce chemin n'est pas standard pour Jenkins. // [/home/jenkins/.auth/admin-secret]: Jenkins s'installe dans /var/lib/ pas dans le home directory. // [/opt/jenkins/security/init.key]: Ce chemin n'existe pas par défaut.
Q: Dans la structure du projet Maven créé, où se trouve le fichier pom.xml ? || R: À la racine du projet || Pièges: [Dans le dossier src/]: src/ contient le code source, pas la configuration Maven. // [Dans le dossier config/]: Maven n'utilise pas de dossier config/ par défaut. // [Dans le dossier target/]: target/ contient les fichiers compilés, pas la configuration.
Q: Quel fichier .NET définit les dépendances NuGet et le framework cible du projet ? || R: *.csproj || Pièges: [packages.config]: packages.config est l'ancien format, .csproj est le format moderne. // [nuget.json]: nuget.json n'existe pas. // [dependencies.xml]: dependencies.xml n'est pas un fichier .NET standard.
Q: Pourquoi les stages GitLab CI/CD s'exécutent-ils séquentiellement alors que les jobs d'un même stage s'exécutent en parallèle ? || R: Pour garantir que les dépendances entre étapes sont respectées (ex: tester après avoir buildé) || Pièges: [C'est une limitation technique de GitLab]: C'est un choix de design logique, pas une limitation. // [Pour économiser les ressources du runner]: Le parallélisme consomme plus de ressources, pas moins. // [Les stages s'exécutent aussi en parallèle]: Les stages sont bien séquentiels par défaut.
Q: Quelle est la différence entre le mot-clé 'script' et 'before_script' dans .gitlab-ci.yml ? || R: before_script s'exécute avant chaque job, script contient les commandes principales || Pièges: [Ils sont identiques, c'est juste une question de style]: Ils ont des rôles distincts dans l'ordre d'exécution. // [script s'exécute en premier, before_script en dernier]: C'est l'inverse: before_script AVANT script. // [before_script est optionnel et n'a aucun effet]: before_script s'exécute bien et affecte le job.
Q: Quelle commande est exécutée dans le job build-dotnet du .gitlab-ci.yml ? || R: dotnet restore && dotnet build --configuration Release || Pièges: [dotnet build]: Il manque le restore et la configuration Release. // [msbuild /p:Configuration=Release]: msbuild est Windows, le TP utilise la CLI dotnet. // [dotnet compile]: 'dotnet compile' n'existe pas.
Q: Dans un Jenkinsfile, quelle syntaxe définit un stage ? || R: stage('Build') { steps { } } || Pièges: [stage: 'Build']: C'est la syntaxe YAML GitLab, pas Groovy Jenkins. // [stages { Build { } }]: La syntaxe correcte est stage('Name') pas stages { Name { } }. // [- stage: Build]: Le tiret est YAML, pas Groovy.
Q: Dans Jenkins, quelle commande permet d'exécuter un script shell ? || R: sh 'commande' || Pièges: [run 'commande']: 'run' n'est pas une fonction Jenkins pipeline. // [shell 'commande']: 'shell' n'existe pas, c'est 'sh'. // [exec 'commande']: 'exec' n'est pas la syntaxe Jenkins.
Q: Quelle fonction Jenkins change le répertoire de travail pour exécuter des commandes ? || R: dir('/chemin') { } || Pièges: [cd('/chemin')]: cd est une commande shell, pas une fonction Jenkins. // [chdir('/chemin') { }]: chdir n'existe pas en Jenkins DSL. // [workdir('/chemin')]: workdir n'est pas une fonction Jenkins standard.
Q: Pourquoi utilise-t-on 'bat' au lieu de 'sh' dans un Jenkinsfile sur Windows ? || R: sh exécute des commandes shell Unix, bat exécute des commandes cmd Windows || Pièges: [bat est plus rapide que sh]: La performance n'est pas la différence. // [bat est la nouvelle version de sh]: Ce sont deux commandes différentes pour deux OS. // [Les deux sont interchangeables]: sh ne fonctionne pas sur Windows sans Cygwin/WSL.
Q: Quelle commande vérifie que Tomcat est actif sur Linux ? || R: systemctl status tomcat10 || Pièges: [tomcat status]: 'tomcat' n'est pas une commande système. // [service tomcat check]: La syntaxe est 'systemctl' pas 'service ... check'. // [tomcat --status]: Tomcat n'a pas d'option --status directe.
Q: Pourquoi le port 80 nécessite-t-il des droits root sur Linux alors que 8080 n'en a pas besoin ? || R: Les ports inférieurs à 1024 sont privilégiés et nécessitent root || Pièges: [80 est un port réservé exclusivement au système d'exploitation]: 80 n'est pas 'réservé', il est privilégié. // [8080 est le seul port compatible avec la machine virtuelle Java]: 8080 n'est pas spécifique à Java, c'est une convention. // [C'est une configuration de sécurité spécifique à Tomcat par défaut]: C'est une règle Linux, pas Tomcat.
Q: Quelle dépendance Maven doit être ajoutée avec scope 'provided' pour le déploiement Tomcat externe ? || R: spring-boot-starter-tomcat || Pièges: [spring-boot-starter-web]: spring-boot-starter-web reste en scope 'compile'. // [javax.servlet-api]: C'est la dépendance starter-tomcat qui englobe les APIs servlet. // [tomcat-embed-core]: tomcat-embed-core est déjà inclus dans starter-tomcat.
Q: Quelle commande copie le fichier WAR vers Tomcat dans le job de déploiement GitLab ? || R: sudo cp springboot-app/target/*.war /var/lib/tomcat10/webapps/ || Pièges: [cp -r target/* /usr/share/tomcat/webapps/ ROOT.war]: Il manque 'sudo' et le chemin 'springboot-app/'. // [deploy --source target/*.war --dest /var/lib/tomcat --force]: 'deploy' n'est pas une commande système. // [scp -i key.pem target/*.war admin@localhost:/webapps/deploy/]: scp est pour la copie distante, pas locale.
Q: Après avoir copié le WAR, quelle commande redémarre Tomcat ? || R: sudo systemctl restart tomcat10 || Pièges: [tomcat restart]: 'tomcat' n'est pas une commande directe. // [service tomcat reload]: 'reload' ne redémarre pas complètement le service. // [/etc/init.d/tomcat restart]: /etc/init.d est l'ancien système, systemctl est le standard moderne.
Q: Pourquoi utilise-t-on un Shell runner plutôt qu'un Docker runner pour déployer sur Tomcat local ? || R: Le Shell runner a accès direct aux services locaux (Tomcat, fichiers système) || Pièges: [Docker runner est trop lent pour les déploiements locaux]: La vitesse n'est pas le facteur déterminant. // [Docker ne supporte pas le déploiement d'applications Java natives]: Docker supporte parfaitement Java. // [Le Shell runner garantit une isolation de sécurité supérieure à Docker]: Le Shell runner est généralement moins isolé que Docker.
Q: Quelles variables CI/CD doivent être configurées dans GitLab pour SonarCloud ? || R: SONAR_TOKEN, SONAR_HOST_URL, SONAR_ORGANIZATION || Pièges: [SONAR_USER, SONAR_PASSWORD, SONAR_DB_URL]: SonarCloud utilise des tokens, pas user/password. // [SONARCLOUD_KEY, SONARCLOUD_SECRET, SONAR_PROJECT]: Ces noms de variables ne sont pas standard. // [SONAR_API_KEY, SONAR_SERVER, SONAR_LOGIN]: Il faut les trois variables, pas une seule.
Q: Pourquoi faut-il définir GIT_DEPTH: '0' pour l'analyse SonarCloud ? || R: Pour cloner tout l'historique Git, nécessaire pour certaines analyses || Pièges: [Pour accélérer le clonage en ne téléchargeant que le dernier commit]: GIT_DEPTH: '0' ralentit le clonage car tout l'historique est téléchargé. // [Pour limiter la taille du dépôt et économiser l'espace disque du runner]: C'est l'inverse: '0' télécharge tout, une valeur numérique limite. // [Pour ignorer les sous-modules et les fichiers binaires volumineux]: GIT_DEPTH ne concerne pas les sous-modules.
Q: Quelle est la différence entre un Bug, un Code Smell et une Vulnerability dans SonarCloud ? || R: Bug = erreur, Code Smell = bonne pratique, Vulnerability = faille || Pièges: [Ce sont trois noms synonymes pour désigner n'importe quel défaut]: Ce sont trois catégories distinctes avec des impacts différents. // [Bug = sécurité, Vulnerability = performance, Code Smell = style]: Les catégories sont mal définies dans cette réponse. // [Bug = crash, Code Smell = style, Vulnerability = bug mineur]: Les trois types peuvent nécessiter une correction selon le contexte.
Q: Où configure-t-on le token SonarCloud dans Jenkins ? || R: Manage Jenkins → Credentials → Add Credentials (Secret text) || Pièges: [Manage Jenkins → Global Tool Configuration]: Global Tool Configuration est pour les outils (JDK, Maven), pas les credentials. // [Job Configuration → Environment Variables]: Les secrets ne doivent pas être en clair dans la configuration du job. // [Manage Jenkins → Plugins → SonarQube Settings]: Les Plugins ne stockent pas les credentials.
Q: Quelle fonction Jenkins injecte automatiquement les variables SonarCloud dans le pipeline ? || R: withSonarQubeEnv('SonarCloudServer') || Pièges: [sonarEnv('SonarCloudServer')]: sonarEnv n'est pas la syntaxe correcte. // [useSonar('SonarCloudServer')]: useSonar n'existe pas. // [injectSonar('SonarCloudServer')]: injectSonar n'est pas une fonction Jenkins.
Q: Pourquoi place-t-on généralement le stage d'analyse SonarCloud APRÈS le stage de build ? || R: SonarCloud a besoin des fichiers compilés (.class) pour certaines analyses || Pièges: [C'est purement esthétique pour avoir un pipeline ordonné chronologiquement]: L'ordre a une importance fonctionnelle. // [SonarCloud compile lui-même le code source avant de l'analyser]: SonarCloud analyse le code, il ne compile pas. // [Le stage peut être placé n'importe où, l'ordre n'a aucune importance]: L'ordre impacte la qualité de l'analyse.
Q: Pourquoi utilise-t-on une branche 'develop' intermédiaire plutôt que de pusher directement sur 'main' ? || R: develop permet d'intégrer et tester les features avant de les mettre en production sur main || Pièges: [C'est une obligation technique imposée par le protocole Git standard]: Ce n'est pas obligatoire, c'est une bonne pratique (Git Flow). // [develop est plus rapide à déployer car elle ne contient pas les tags de version]: La vitesse n'est pas le facteur. // [main est protégée en écriture et ne peut jamais recevoir de nouveaux commits]: main peut recevoir des commits via MR.
Q: Comment le SAST détecte-t-il une injection SQL dans le code source ? || R: Il analyse le code statiquement et détecte les patterns dangereux (concaténation de strings) || Pièges: [Il exécute le code dans un environnement sandbox et teste les entrées]: C'est DAST (Dynamic) qui exécute le code, pas SAST. // [Il se connecte à la base de données de production pour simuler des attaques]: SAST n'interagit pas avec l'infrastructure. // [Il vérifie les logs d'erreurs du serveur d'application en temps réel]: L'analyse des logs est du monitoring, pas du SAST.
Q: Pourquoi les fichiers .env ne doivent-ils JAMAIS être committés dans Git ? || R: Ils contiennent souvent des secrets (clés API, mots de passe) qui seraient exposés || Pièges: [Git ne supporte techniquement pas le versionnement des fichiers .env]: Git peut parfaitement versionner les .env, c'est juste dangereux. // [Ils sont trop volumineux et ralentiraient les opérations de clonage]: La taille n'est pas le problème. // [.env est un format obsolète qui n'est plus reconnu par les outils modernes]: .env est toujours largement utilisé.
Q: Comment corriger une injection SQL détectée par SAST ? || R: Utiliser des requêtes paramétrées (PreparedStatement) au lieu de concaténer || Pièges: [Supprimer complètement la requête SQL du code source]: Supprimer la requête n'est pas une solution viable. // [Encoder le paramètre utilisateur en base64 avant la requête]: Base64 est un encodage, pas une protection contre l'injection. // [Ajouter des doubles guillemets autour du paramètre dans la chaîne]: Les guillemets peuvent être contournés par des techniques d'évasion.
Q: Quel outil est utilisé par GitLab pour le scan SAST ? || R: Semgrep || Pièges: [SonarQube]: SonarQube est pour l'analyse de qualité, pas le SAST GitLab natif. // [Checkmarx]: Checkmarx est un outil commercial, pas intégré nativement. // [Fortify]: Fortify est également un outil commercial séparé.
Q: Comment corriger un secret hardcodé dans .env pour les pipelines CI/CD ? || R: Ajouter .env au .gitignore + créer une variable CI/CD masquée dans GitLab || Pièges: [Chiffrer le fichier .env avec une clé GPG sécurisée avant le commit]: Le chiffrement complique et ne résout pas le problème de versionnement. // [Renommer .env en .env.local pour qu'il ne soit pas détecté]: Renommer ne retire pas le fichier du dépôt Git. // [Compresser .env en .env.zip avec un mot de passe fort]: La compression n'est pas une solution de sécurité.
Q: Dans GitLab, où configure-t-on l'option 'Masked' pour protéger une variable ? || R: Project → Settings → CI/CD → Variables || Pièges: [Project → Settings → Repository → Protected]: Repository → Protected concerne les branches, pas les variables. // [Project → Settings → Security]: Settings → Security concerne d'autres configurations. // [Project → CI/CD → Pipeline Editor]: Pipeline Editor est pour éditer le .gitlab-ci.yml.
Q: Pourquoi la règle '1 vulnérabilité = 1 branche = 1 MR' est-elle une bonne pratique ? || R: Pour permettre une revue ciblée, un rollback facile, et une traçabilité complète || Pièges: [Pour générer plus de commits]: Le nombre de commits n'est pas l'objectif. // [Pour ralentir le développement]: Cela structure le travail, pas le ralentit. // [C'est obligatoire dans GitLab]: C'est une bonne pratique, pas une obligation.
Q: Pourquoi Ansible utilise-t-il SSH plutôt qu'un agent installé sur les machines cibles ? || R: Architecture agentless: pas besoin d'installer/maintenir un agent sur chaque serveur || Pièges: [SSH est plus lent mais plus fiable]: SSH n'est pas plus lent que les agents. // [SSH est obligatoire pour tous les outils de configuration]: D'autres outils comme Chef/Puppet utilisent des agents. // [Ansible ne peut pas utiliser d'autres protocoles]: Ansible peut aussi utiliser WinRM pour Windows.
Q: Quelle est la différence entre la clé publique et la clé privée SSH ? || R: La clé publique est partagée avec les serveurs, la clé privée reste secrète sur votre machine || Pièges: [Les deux sont identiques avec des noms différents]: Elles sont mathématiquement liées mais différentes. // [La clé privée est envoyée aux serveurs]: C'est l'inverse: la clé publique va sur les serveurs. // [Seule la clé publique est chiffrée]: Les deux sont des clés cryptographiques.
Q: Pourquoi utilise-t-on 'ssh-copy-id' plutôt que de copier manuellement la clé ? || R: Il ajoute automatiquement la clé dans authorized_keys avec les bonnes permissions || Pièges: [ssh-copy-id est plus rapide]: La vitesse n'est pas le facteur principal. // [La copie manuelle est impossible]: La copie manuelle est possible mais plus risquée. // [ssh-copy-id chiffre la clé]: La clé publique n'a pas besoin d'être chiffrée.
Q: À quoi servent les groupes (ex: [webservers]) dans le fichier inventory Ansible ? || R: Permettent de cibler des ensembles de serveurs avec des playbooks spécifiques || Pièges: [Purement décoratif]: Les groupes ont une utilité fonctionnelle importante. // [Obligatoires pour que Ansible fonctionne]: On peut utiliser 'all' sans définir de groupes. // [Définissent les permissions des utilisateurs]: Les groupes ne gèrent pas les permissions OS.
Q: Quelle commande Ansible exécute un module shell sur tous les hosts ? || R: ansible all -m shell -a 'whoami && hostname' || Pièges: [ansible all -m command -a 'whoami']: Le module 'command' fonctionne mais 'shell' permet les pipes et redirections. // [ansible-run all 'whoami']: 'ansible-run' n'existe pas. // [ansible exec all 'whoami']: 'ansible exec' n'est pas la syntaxe correcte.
Q: Quelle est la différence entre un module Ansible 'command' et 'shell' ? || R: shell permet les pipes, redirections et variables d'environnement, command exécute directement || Pièges: [Ils sont identiques]: Ils ont des comportements différents. // [command est plus sécurisé mais plus lent]: La sécurité et la vitesse ne sont pas les différences principales. // [shell ne fonctionne que sur Linux]: shell fonctionne partout où un shell est disponible.
Q: Que fait le module Ansible 'copy' comparé au module 'fetch' ? || R: copy envoie des fichiers vers les hosts, fetch récupère des fichiers depuis les hosts || Pièges: [copy et fetch font la même chose]: Ils ont des directions opposées. // [fetch est plus rapide]: La vitesse dépend de la taille du fichier, pas du module. // [copy ne fonctionne qu'avec des fichiers texte]: Les deux fonctionnent avec tous types de fichiers.
Q: Pourquoi utilise-t-on le module 'stat' avant 'copy' dans un playbook ? || R: Pour vérifier si le fichier existe déjà et éviter une copie inutile (idempotence) || Pièges: [stat est obligatoire avant toute copie de fichier pour éviter les erreurs d'écriture]: stat est optionnel, c'est une bonne pratique. // [stat accélère significativement le transfert en compressant les données]: stat ne change pas la vitesse de copie. // [stat convertit automatiquement le format du fichier (encodage, fin de ligne)]: stat ne modifie pas les fichiers.
Q: Que signifie 'idempotence' dans le contexte Ansible ? || R: Lancer un playbook plusieurs fois produit toujours le même état final stable || Pièges: [Le playbook ne peut être exécuté qu'une seule fois par machine cible]: Un playbook peut être exécuté plusieurs fois. // [Ansible détecte et corrige automatiquement toutes les erreurs de syntaxe]: L'idempotence ne concerne pas la détection d'erreurs. // [Les tâches s'exécutent simultanément sur tous les cœurs du processeur]: Le parallélisme est une autre fonctionnalité.
Q: Dans .gitlab-ci.yml, quelle est la bonne syntaxe pour définir un artifact avec expiration ? || R: artifacts:\n paths:\n - target/*.war\n expire_in: 1 week || Pièges: [artifacts: [paths: 'target/*.war', expire: '1 week', when: 'always']]: La syntaxe YAML n'utilise pas les crochets ainsi. // [save_artifacts:\n  files:\n    - target/*.war\n  lifetime: 7 days]: 'save_artifacts' n'existe pas. // [output:\n  target: target/*.war\n  retention: 1 week]: 'output' et 'expiration' ne sont pas des clés valides.
Q: Comment déclare-t-on l'agent dans un Jenkinsfile déclaratif ? || R: agent any || Pièges: [runner any]: 'runner' est terminologie GitLab, pas Jenkins. // [executor: any]: 'executor' n'est pas la syntaxe Jenkinsfile. // [node any]: 'node' est utilisé en scripted pipeline, pas déclaratif.
Q: Quelle variable GitLab CI contient le chemin du répertoire du projet ? || R: $CI_PROJECT_DIR || Pièges: [$PROJECT_PATH]: $PROJECT_PATH n'est pas une variable GitLab prédéfinie. // [$WORKSPACE]: $WORKSPACE est utilisé par Jenkins, pas GitLab. // [$GIT_DIR]: $GIT_DIR est le dossier .git, pas le projet.
Q: Quelle est la commande complète pour lancer l'analyse SonarCloud avec Maven ? || R: mvn clean verify sonar:sonar -Dsonar.projectKey=... -Dsonar.host.url=... -Dsonar.token=... || Pièges: [mvn sonar:sonar -Dsonar.login=admin -Dsonar.password=admin --batch-mode]: mvn sonar:sonar seul nécessite les paramètres en plus. // [mvn analyze:sonarcloud --with-token=$SONAR_TOKEN --full-scan]: analyze:sonarcloud n'est pas un goal Maven valide. // [mvn sonarcloud:scan -Dproject.settings=sonar-project.properties --force]: sonarcloud:scan n'existe pas.
Q: Que fait la commande 'mvn clean' ? || R: Supprime le dossier target/ contenant tous les fichiers générés (classes, JAR/WAR) || Pièges: [Nettoie le cache local Maven (~/.m2) pour forcer le téléchargement]: Le cache Maven (.m2/repository) n'est pas affecté par clean. // [Supprime les dépendances orphelines déclarées dans le pom.xml]: clean ne gère pas les dépendances. // [Réinitialise le fichier pom.xml à sa configuration par défaut]: pom.xml n'est jamais modifié par clean.
Q: Quelle est la différence entre 'mvn compile' et 'mvn package' ? || R: compile compile le code source, package exécute compile + test + création du JAR/WAR || Pièges: [compile crée l'archive JAR/WAR, alors que package compile uniquement les classes]: C'est l'inverse: compile ne crée pas le JAR. // [Ils sont identiques et peuvent être utilisés de manière interchangeable]: Ils ont des phases différentes. // [package prépare le projet pour le déploiement mais ne compile pas le code]: package inclut la compilation.
Q: Que signifie l'option -DskipTests dans 'mvn clean package -DskipTests' ? || R: Skip l'exécution des tests mais les compile || Pièges: [Skip la compilation des tests]: Les tests sont compilés, juste pas exécutés. // [Supprime les fichiers de test]: Aucun fichier n'est supprimé. // [Désactive le plugin de test]: Le plugin reste actif, seule l'exécution est skippée.
Q: Que fait 'mvn test' exactement ? || R: Compile le code, compile les tests, puis exécute les tests || Pièges: [Exécute uniquement les tests]: Il compile aussi avant de tester. // [Affiche la liste des tests disponibles]: Il exécute les tests, ne les liste pas. // [Génère un rapport de couverture]: La couverture nécessite Jacoco ou un plugin spécifique.
Q: Quelle commande crée un nouveau projet Maven interactif ? || R: mvn archetype:generate || Pièges: [mvn new project]: new n'est pas un goal Maven. // [mvn init]: init n'existe pas dans Maven (c'est npm/git). // [mvn create:project]: create:project n'est pas un goal valide.
Q: Que fait 'mvn install' de plus que 'mvn package' ? || R: Il installe l'artifact (JAR/WAR) dans le repository local Maven (~/.m2/repository) || Pièges: [Il déploie l'application sur un serveur d'application distant configuré]: Le déploiement distant est fait par 'mvn deploy'. // [Il télécharge et installe toutes les dépendances manquantes du projet]: Les dépendances sont téléchargées automatiquement, pas par install. // [Il génère les fichiers de configuration pour l'IDE (IntelliJ/Eclipse)]: install ne configure pas le projet.
Q: Quelle commande crée une nouvelle branche ET se positionne dessus ? || R: git checkout -b nouvelle-branche || Pièges: [git branch nouvelle-branche --switch]: git branch crée la branche mais reste sur la branche actuelle. // [git new branch -name nouvelle-branche]: git new n'existe pas. // [git create --branch nouvelle-branche]: git create n'existe pas.
Q: Quelle est la différence entre 'git merge' et 'git rebase' ? || R: merge crée un commit de fusion, rebase réécrit l'historique linéairement || Pièges: [Ils font exactement la même chose, c'est une question de préférence]: Ils ont des résultats différents sur l'historique. // [rebase fusionne les branches avec un commit, merge réécrit l'historique]: C'est l'inverse. // [merge est limité à 2 branches, rebase peut en gérer plusieurs]: merge peut fusionner plusieurs branches.
Q: Que fait 'git push origin develop' ? || R: Envoie la branche develop locale vers le remote origin || Pièges: [Télécharge la branche develop depuis origin]: C'est 'git pull' ou 'git fetch' qui télécharge. // [Supprime la branche develop sur origin]: La suppression serait: git push origin --delete develop. // [Crée une nouvelle branche origin/develop]: origin/develop est une référence de tracking, pas créée par push.
Q: Que fait 'git stash' ? || R: Sauvegarde temporairement les modifications sans committer || Pièges: [Supprime les modifications non committées]: Les modifications sont sauvegardées, pas supprimées. // [Crée un nouveau commit]: stash ne crée pas de commit visible dans l'historique. // [Fusionne les branches]: stash ne fusionne rien.
Q: Comment annuler les modifications d'un fichier non encore stagé (add) ? || R: git checkout -- fichier || Pièges: [git reset HEAD fichier]: reset HEAD est pour désindexer un fichier déjà stagé. // [git revert fichier]: revert annule un commit entier, pas un fichier. // [git undo fichier]: git undo n'existe pas.
Q: Que fait 'dotnet restore' ? || R: Télécharge les packages NuGet définis dans .csproj || Pièges: [Restaure le projet à son état initial]: restore concerne les dépendances, pas l'état du projet. // [Restaure une sauvegarde du projet]: Ce n'est pas un système de backup. // [Répare les fichiers corrompus]: restore ne répare pas les fichiers.
Q: Quelle option de 'dotnet build' compile en mode Release ? || R: --configuration Release || Pièges: [--release]: --release n'est pas une option directe de build. // [-r Release]: -r est pour le runtime identifier, pas la configuration. // [--mode Release]: --mode n'existe pas.
Q: Que fait 'dotnet run' ? || R: Compile puis exécute l'application en une seule commande || Pièges: [Exécute l'application sans la compiler]: run compile avant d'exécuter si besoin. // [Affiche la liste des projets disponibles]: Ce n'est pas une commande de listing. // [Lance les tests]: Pour les tests c'est 'dotnet test'.
Q: Quelle est la différence entre 'npm install' et 'npm ci' ? || R: ci utilise strictement package-lock.json (reproductible), install peut le modifier || Pièges: [ci installe les devDependencies, alors que install les ignore par défaut]: Les deux installent toutes les dépendances. // [ci est beaucoup plus lent que install car il vérifie chaque paquet]: ci est souvent plus rapide car il supprime node_modules et fait une install propre. // [install est déprécié depuis Node 14, ci est le nouveau standard]: Les deux sont toujours utilisés selon le contexte.
Q: Que fait 'npm run build' ? || R: Exécute le script 'build' défini dans package.json || Pièges: [Compile le code Node.js natif]: npm n'a pas de compilation native automatique. // [Crée un fichier package.json]: La création se fait avec 'npm init'. // [Met à jour les dépendances]: La mise à jour se fait avec 'npm update'.
Q: Comment sauvegarder une dépendance en tant que devDependency ? || R: npm install package --save-dev || Pièges: [npm install package --dev]: --dev seul n'est pas la syntaxe correcte. // [npm install-dev package]: install-dev n'existe pas. // [npm dev install package]: La syntaxe est npm install ... --save-dev.
Q: Que fait 'ansible all -m ping' ? || R: Teste la connexion SSH et la disponibilité de l'interpréteur Python || Pièges: [Envoie un paquet ICMP (réseau) à tous les serveurs listés]: Le ping Ansible n'est pas un ping réseau ICMP. // [Affiche la liste détaillée de tous les hosts de l'inventory]: Pour lister: ansible-inventory --list. // [Vérifie la syntaxe des fichiers de configuration YAML]: Pour vérifier la syntaxe: ansible-lint.
Q: Comment exécuter un playbook avec un inventory spécifique ? || R: ansible-playbook -i inventory.ini playbook.yml || Pièges: [ansible-playbook playbook.yml inventory.ini]: L'option -i est requise pour l'inventory. // [ansible playbook.yml --inventory=inventory.ini]: ansible sans -playbook exécute des modules ad-hoc. // [ansible-run -i inventory.ini playbook.yml]: ansible-run n'existe pas.
Q: Quelle option permet de voir ce que fera un playbook sans l'exécuter (dry-run) ? || R: --check || Pièges: [--dry-run]: --dry-run n'est pas l'option Ansible. // [--preview]: --preview n'existe pas. // [--test]: --test n'est pas une option valide.
Q: Comment exécuter une commande shell sur un groupe de hosts 'webservers' ? || R: ansible webservers -m shell -a 'df -h' || Pièges: [ansible -g webservers 'df -h']: -g n'est pas une option valide. // [ansible-shell webservers 'df -h']: ansible-shell n'existe pas. // [ansible webservers --command 'df -h']: --command n'est pas la syntaxe correcte.
Q: Que génère 'ssh-keygen -t rsa -b 4096' ? || R: Une paire de clés RSA (publique et privée) de 4096 bits || Pièges: [Une clé symétrique AES]: RSA est asymétrique, pas symétrique. // [Un certificat SSL]: ssh-keygen génère des clés SSH, pas SSL. // [Un mot de passe sécurisé]: C'est une clé cryptographique, pas un mot de passe.
Q: Que fait 'ssh-copy-id user@host' ? || R: Copie la clé publique dans ~/.ssh/authorized_keys du serveur || Pièges: [Copie la clé privée vers le serveur]: JAMAIS copier la clé privée! C'est la publique qui est copiée. // [Génère une nouvelle clé sur le serveur]: La clé est sur votre machine, pas générée sur le serveur. // [Supprime les anciennes clés du serveur]: Les anciennes clés sont conservées.
Q: Quelle commande redémarre le service Tomcat ? || R: sudo systemctl restart tomcat10 || Pièges: [systemctl tomcat restart]: L'ordre est: systemctl <action> <service>. // [tomcat --restart]: tomcat n'est pas une commande directe. // [service restart tomcat10]: La syntaxe service est: service tomcat10 restart.
Q: Comment voir les logs en temps réel d'un service ? || R: journalctl -u tomcat10 -f || Pièges: [systemctl logs tomcat10]: systemctl logs n'existe pas. // [tail -f /var/log/tomcat10]: Le chemin exact dépend de la config, journalctl est plus fiable. // [systemctl --follow tomcat10]: --follow n'est pas une option systemctl.
Q: Que fait 'docker run hello-world' ? || R: Télécharge et exécute l'image hello-world pour tester Docker || Pièges: [Affiche 'hello-world' dans le terminal]: C'est plus qu'un simple echo. // [Crée un nouveau fichier hello-world]: Aucun fichier n'est créé. // [Démarre le service Docker]: Le service Docker doit déjà être démarré.
Q: Comment afficher tous les conteneurs (y compris arrêtés) ? || R: docker ps -a || Pièges: [docker ps]: docker ps sans option montre seulement les conteneurs actifs. // [docker list --all]: docker list n'existe pas. // [docker containers]: La commande correcte est 'docker ps' pas 'docker containers'.
Q: Dans un Jenkinsfile, quelle est la différence entre 'sh' et 'bat' ? || R: sh est pour shell Unix/Linux, bat est pour Windows cmd.exe || Pièges: [bat est la version moderne et optimisée de la commande sh]: Les deux existent depuis longtemps. // [sh est significativement plus lent que bat sur toutes les plateformes]: La performance dépend du système, pas de la commande. // [Ils sont parfaitement interchangeables quel que soit l'OS]: sh ne fonctionne pas sur Windows sans Cygwin/WSL.
Q: Comment changer de répertoire dans un Jenkinsfile ? || R: dir('/path') { ... } || Pièges: [sh 'cd /path && ...']: cd dans sh fonctionne mais dir est plus propre et Jenkins-natif. // [cd '/path']: cd n'est pas une fonction Jenkins. // [chdir('/path')]: chdir n'existe pas en Jenkins DSL.
Q: Dans .gitlab-ci.yml, comment exécuter plusieurs commandes dans un script ? || R: script:\n - cmd1\n - cmd2\n - cmd3 || Pièges: [script: 'cmd1 && cmd2 && cmd3']: Une seule string avec && fonctionne mais la liste est plus lisible. // [commands: [cmd1, cmd2, cmd3]]: La clé s'appelle 'script' pas 'commands'. // [run: cmd1; cmd2; cmd3]: 'run' n'est pas une clé GitLab CI valide.
Q: Comment accéder à une variable CI/CD définie dans GitLab ? || R: $VARIABLE ou ${VARIABLE} || Pièges: [${VARIABLE}]: Les deux syntaxes fonctionnent. // [%VARIABLE%]: %VAR% est la syntaxe Windows cmd, pas shell. // [{{VARIABLE}}]: {{}} est la syntaxe Jinja2/Ansible, pas shell.
